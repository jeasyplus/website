# Flink

## 流处理

无论是来自 Web 服务器的事件、交易，还是工厂车间机器的传感器读数，数据都是作为流的一部分被创建。

![flink](https://jeasyplus.com/flink/stream.png)

在概念上，输入可能永远不会结束，因此被迫随着数据的不断地处理，无界数据流。

![flink](https://jeasyplus.com/flink/program_dataflow.svg)
![flink](https://jeasyplus.com/flink/program_dataflow_1.svg)

### transformation

将一个或多个数据流（DataStream）经过特定的操作，生成一个新的数据流的过程。Flink 的数据流处理模型是基于连续流式数据处理，数据通过数据流（DataStream）的形式在算子之间流动。

Flink 提供了一系列的 Transformation 操作，用于对数据流进行不同的处理和转换。常见的 Transformation 操作包括：

+ Map：对数据流中的每个元素应用一个函数，返回一个新的元素。可以将输入流中的每个元素转换为不同的形式或类型。

+ Filter：对数据流中的每个元素应用一个条件，只保留满足条件的元素。

+ KeyBy：按照指定的键对数据流进行分组，将具有相同键的元素放入同一个分区中。

+ Reduce：对数据流中**按键分组后**的每个分区应用一个 reduce 函数，将每个分区中的元素合并成一个元素。

+ Window：将数据流划分为**不重叠的窗口**，并在每个窗口上应用相应的**聚合操作**，实现滚动窗口或滑动窗口的计算。

+ Join：将两个或多个数据流中具有相同键的元素进行关联，生成一个新的数据流。

+ Union：将多个数据流合并成一个数据流，不保留分区。

## 并行数据流

Flink 程序在执行过程中以并行和分布式的方式处理数据流。

数据流被划分为一个或多个数据流分区（stream partition），

每个算子（operator）被划分为一个或多个运算符子任务（operator subtask）。

这些运算符子任务是相互独立的，它们在不同的线程、可能在不同的机器或容器上运行。

运算符子任务的数量就是该特定算子的并行度（parallelism）。

同一个程序中的不同算子可以有不同的并行度。并行度决定了一个算子在多个运算符子任务上并行执行的能力，也就是同时处理数据的能力。


## 并行度

决定了任务的并发执行能力，较高的并行度可以充分利用集群的计算资源，提高任务的处理能力和吞吐量。

默认并行度等于 Flink 集群可用的 TaskManager 数量。

### 驱动表

驱动表的数据会被广播到所有并行任务中。

Flink 会选择并行度低的作为驱动表，驱动表的并行度较低，广播的数据量相对较小，可以更快速地发送和处理数据，减少网络通信开销。

如果驱动表的并行度很高，处理的数据量远远超过其他任务，可能会导致数据倾斜，导致计算资源不均衡，影响整体性能。

如果确实需要显式指定驱动表，可以使用 withBroadcastSet 方法将数据广播到所有并行任务中，实现手动指定驱动表的效果。








