# 设计模式 - Java

## 创建型模式（Creational Patterns）

### 单例模式（Singleton Pattern）

单例模式的核心思想是确保一个类只有一个实例，并提供全局访问点。

**应用场景：**
+ 频繁访问的共享资源，如数据库连接池、线程池等。
+ 控制资源的实例数量，如操作系统的文件系统管理器。
+ 创建唯一的对象，如日志记录器、配置文件管理器等

### 工厂模式（Factory Pattern）

工厂模式（Factory Pattern）的核心思想是将对象的创建和使用分离，隐藏对象的创建细节方便扩展。

**应用场景：**
+ 需要根据不同的条件或参数来创建不同类型的对象。
+ 隐藏对象创建细节，提供一个统一的接口供客户端使用。
+ 需要根据具体需求扩展和定制对象的创建逻辑。

### 抽象工厂模式（Abstract Factory Pattern）

抽象工厂模式（Abstract Factory Pattern）的核心思想是提供一个接口或抽象类，用于创建一组相关的对象，而无需要指定具体的类，且保证对象之间一致性。

**应用场景：**
+ 需要创建一组相关或依赖的对象，这些对象之间具有一致性。
+ 需要隐藏对象的具体创建细节，只关注对象的接口或抽象类。
+ 需要根据不同的条件或参数创建不同类型的对象组合。

### 建造者模式（Builder Pattern）
建造者模式的核心思想是将对象的构建过程抽象出来，由独立的建造者对象负责执行构建步骤，使得构建过程更加灵活和可复用。

**示例：**

客户端需要一个**产品**，产品支持定制化，不同的定制化产品由不同的**构建者**负责，当**构建者**把产品创建出来交给**指挥者**，**指挥者**对产品 **参数（属性值）** 进行定制。

**应用：**

客户端可以选择不同的**构建者**和不同的**指挥者**，最终**组合出不同的产品**。

### 原型模式（Prototype Pattern）

原型模式（Prototype Pattern）的核心思想是通过**复制**现有对象的状态来**代替创建**，从而避免了直接**实例化带来的开销**。

**应用：**
+ 对象的创建和初始化过程**过于复杂**时。

## 结构型模式（Structural Patterns）：

### 适配器模式（Adapter Pattern）

适配器模式核心思想是将**现有接口**转换成客户端所**期望的接口**，从而**让不兼容的类能够协同工作**。

+ 将旧接口适配到新接口
+ 统一多个类的接口
+ 封装第三方库或组件

### 桥接模式（Bridge Pattern）

桥接模式核心思想是先将**抽象**和**实现**分别定义为**独立**的类，然后，使用**桥接**类把二者结合起来，以达到**抽象**与**实现**的**自由**变化。

**应用：**
+ 希望在多个维度上进行扩展，而不想产生类爆炸的情况时。
+ 希望在运行时选择不同的实现时。

### 组合模式（Composite Pattern）

组合模式核心思想是将一组有**差异化且密切相关**的对象，有效的组织在一起，并**屏蔽掉差异**的行为，使客户端**统一操作**。

**应用：**
+ 对一系列密切相关又有所差异的对象进行管理时。
+ 需要表示部分-整体层次结构时。

### 装饰器模式（Decorator Pattern）

装饰器模式核心思想是在**不改变原始对象**的情况下，**扩展对象的功能**或行为。

**应用：**
+ 动态扩展对象功能
+ 替代继承
+ 按照需要组合功能

### 外观模式（Facade Pattern）
外观模式核心思想是使用**统一**的接口**操作一组复杂**的接口。

**应用**
+ 当存在一个复杂的子系统，希望提供一个简单的接口来访问该子系统时。
+ 解耦客户端与子系统之间的依赖关系。
+ 希望对子系统进行重构或者修改时。

### 享元模式（Flyweight Pattern）

享元模式核心思想是通过共享减少系统中相似对象的数量。

**应用：**

+当系统中存在大量相似对象，且这些对象可以共享一些公共部分时。

如：棋盘上的棋子，共享相同颜色的棋子，将棋子位置视为其外部状态。

### 代理模式（Proxy Pattern）

代理模式核心思想是通过引入一个对象，控制对目标对象的操作。

**应用：**
+ 隐藏底层细节
+ 延迟对象的实例化
+ 限制对目标对象的访问权限
+ 避免重复计算，缓存结果

## 行为型模式（Behavioral Patterns）：

### 责任链模式（Chain of Responsibility Pattern）
责任链模式核心思想是将不同的处理逻辑（处理者）使用链表的方式串连起来，根据自身的处理能力决定是否接受处理请求，或者将请求传递给下一个处理者。

**应用：**
+ 多个对象可以处理同一请求，由哪个对象来处理请求在运行时才能确定时。
+ 避免请求的发送者和接收者之间的耦合关系时。
+ 动态地组织和管理处理者对象时。


### 命令模式（Command Pattern）

命令模式核心思想是将请求相关信息和对应的操作封装成一个对象，请求的发送者和请求的接收者解耦。

**应用**
+ 请求发送者和请求接收者解耦时。
+ 多种复杂操作时。

### 解释器模式（Interpreter Pattern）
解释器模式核心思想通过定义表达式类和解释器类来实现对语言的解释和执行。

**应用**
+ 自定义的领域特定语言（Domain-Specific Language，DSL）。
+ 解释和执行一些复杂的语法规则。
+ 规则引擎中的规则表达式。

### 迭代器模式（Iterator Pattern）
迭代器模式核心思想是将遍历操作抽象出来，封装在一个对象中，在不暴露集合内部结构的情况，也可以按顺序访问集合中的元素。

**应用：**

+ 需要遍历一个集合对象，并且不希望暴露集合的内部结构给外部。
+ 需要提供一种通用的遍历方式，以便能够适用于不同类型的集合对象。
+ 需要在遍历过程中对集合元素进行操作，而不影响遍历过程。

### 中介者模式（Mediator Pattern）

中介者模式的核心思想是将多个对象之间的交互行为封装成一个对象，减少对象之间的直接依赖。

**应用场景：**

+ 多个对象之间存在复杂的交互关系，导致对象之间的耦合度较高时。
+ 一个对象的行为依赖于其他多个对象的状态变化时。
+ 需要增加或修改对象之间的交互方式时。

### 备忘录模式（Memento Pattern）

备忘录模式核心思想是将对象的状态封装到一个对象中，在需要时将对象恢复到之前的某个状态。

**应用**：

+ 在不破坏对象封装性的前提下保存和恢复对象的状态时。
+ 实现撤销和恢复功能时。
+ 对象的状态变化较为复杂，且需要保存多个不同时间点的状态时。

### 观察者模式（Observer Pattern）
观察者模式核心思想是当对象的状态发生变化时，通知观察者，引入模式解耦对象和观察者之间的关系。

**应用：**

+ 一个对象的状态变化需要通知其他多个对象时。
+ 对象之间存在一对多的依赖关系，并且需要保持低耦合性时。
+ 在对象之间建立动态的、灵活的通信机制时。

### 状态模式（State Pattern）

状态模式核心思想是将对象的状态封装成不同的状态类，当对象的状态发生变化时改对象的行为。

**应用：**

+ 对象的行为依赖于其内部状态，并且行为随状态改变而改变时。
+ 对象的行为在不同状态下有不同的实现逻辑，并且状态之间存在复杂的转换关系时。

### 策略模式（Strategy Pattern）
策略模式核心思想是将不同的算法（策略）封装成独立的类，并在运行时动态切换策略。

**应用：**

+ 根据不同的情况选择不同的算法或策略时。
+ 一个类有多个行为变体，并且这些行为可以在运行时动态切换时。

### 模板方法模式（Template Method Pattern）

模板方法模式核心思想是将算法的**通用部分（算法的骨架）** 定义成抽象类，**个性化的部分**由子类实现。

**应用：**

+ 有一些共同的行为或步骤需要在不同的类中共享时。
+ 需要固定算法的骨架，但允许某些步骤由子类来实现时。

### 访问者模式（Visitor Pattern）

访问者模式核心思想是在数据结构和操作之间引入一个访问者对象，将数据结构与操作分离，在不改变数据结构的前提下定义新的操作。

**应用：**

+ 需要在不改变数据结构的前提下定义新的操作时。
+ 数据结构中的元素类型相对稳定，但操作类型经常变化时。


## 并发型模式（Concurrency Patterns）：

### 读写锁模式（Read-Write Lock Pattern）

读写锁模式的核心思想是在共享资源的访问上引入读锁和写锁，并发读操作，独占写操作。

**应用：**

+ 多个线程同时读取共享资源，但写操作较少且相对耗时时。
+ 共享资源需要保护，读操作和写操作不能同时执行时。

## 线程池模式（Thread Pool Pattern）

线程池模式思想是将线程的创建管理与任务处理分离开来，从而提高系统的效率和性能。

**应用：**

+ 需要高效处理大量的短期任务时。
+ 系统中有多个任务需要异步执行，并且需要对线程进行统一管理时。

### 生产者-消费者模式（Producer-Consumer Pattern）

生产者-消费者模式核心思想是将生产者和消费者解耦，使它们能够并发执行，同时确保线程安全和协调性。

**应用：**

+ 生产者和消费者之间存在明显的耦合关系，并且需要解耦以实现并发执行时。
+ 生产者和消费者之间的速度不匹配，生产者产生数据的速度远远快于消费者处理数据的速度时。


### 信号量模式（Semaphore Pattern）

信号量模式通过引入信号量来限制同时访问某个资源的线程数量。

**应用：**
+ 当需要限制同时访问某个资源的线程数量时。
+ 当需要实现资源池或连接池等功能时。

### 栅栏模式（Barrier Pattern）
栅栏模式通过引入一个栅栏（Barrier）点，使多个线程在该点上等待，直到所有线程都到达栅栏点，然后才能继续执行后续操作。

**应用：**

+ 需要多个线程在某个点上同步执行时。
+ 多个线程需要协调完成某个阶段性任务后再继续执行下一步操作时。

### 并发队列模式（Concurrent Queue Pattern）
并发队列模式通过提供线程安全的队列数据结构，允许多个线程同时对队列进行操作。

**应用：**
+ 需要在多线程环境下安全地共享队列资源时。
+ 多个线程需要同时对队列进行操作，如生产者-消费者模式等，并发队列模式可以提供线程安全的队列操作。











































