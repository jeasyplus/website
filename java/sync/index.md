# synchronized实现原理

synchronized关键字的实现原理涉及到Java对象头（Object Header）和线程监视器（Monitor）的概念。

+ **对象头（Object Header）：** 每个Java对象在内存中都有一个对象头，其中包含了与对象相关的元数据信息，包括锁状态、哈希码、GC相关信息等。

+ **线程监视器（Monitor）：** 当一个线程进入一个被synchronized修饰的代码块或方法时，它会尝试获取该代码块或方法所属对象的线程监视器。线程监视器是与对象关联的锁，用于控制对对象的并发访问。

## synchronized实现原理

+ **进入同步块：** 当线程进入一个被synchronized修饰的代码块或方法时，它会首先尝试获取该代码块或方法所属对象的线程监视器。

+ **锁定对象：** 如果线程成功获取到线程监视器，它就可以执行代码块或方法的操作，并且线程监视器会被标记为“锁定”状态。其他线程在此期间无法获取该对象的线程监视器，进入阻塞状态，直到锁被释放。

+ **释放锁：** 当线程执行完synchronized代码块或方法后，它会释放所持有的线程监视器，将其状态标记为“未锁定”。这样，其他线程就可以继续竞争获取线程监视器，进入临界区执行代码。


## 对象头（Object Header）和线程监视器（Monitor）

当使用 synchronized 关键字时，每个对象实例都有一个与之相关联的监视器锁（也称为内置锁或对象锁）。该锁通过对象头的一部分来实现。

对象头是一个存储在每个Java对象上的元数据结构，用于存储对象的标记信息、类的元数据以及锁的状态。当一个对象被创建时，Java虚拟机会为其分配一块内存来存储对象的数据，并在内存中创建对象头。

+ 在synchronized的过程中，当一个线程尝试进入一个synchronized代码块或方法时，它会**尝试获取该对象实例的监视器锁**。如果锁当前没有被其他线程持有，那么线程可以成功获取锁，并继续执行被标记的代码块或方法。

+ 当线程获取到锁时，Java虚拟机会在对象头中的**锁记录（Lock Record）中记录线程的标识符**，表示该线程持有了锁。这样，其他线程在尝试获取同一个对象的锁时会被阻塞，直到锁被释放。

+ 当线程执行完synchronized代码块或方法时，它会**释放持有的锁**，并将对象头中的**锁记录清除**。这样，其他等待的线程可以有机会获取到锁并继续执行。

总结起来，对象头在synchronized过程中用于存储和管理对象的锁状态，以实现多线程的同步和互斥访问。

## 对象头（Object Header）的结构

```roomsql
|---------------------------|
|    Mark Word (标记字)      |
|---------------------------|
|    Class Pointer (类型指针) |
|---------------------------|
|  Instance Data (实例数据)  |
|---------------------------|
|  Array Length (数组长度)   |
|---------------------------|
|   Monitor (监视器)         |
|---------------------------|
```
在这个示例中，对象头包括以下字段：

+ **Mark Word（标记字）：** 用于存储对象的标记信息，可以用于垃圾回收和同步操作。
+ **Class Pointer（类型指针）：** 指向对象的类元数据，包括对象的方法和字段定义等信息。
+ **Instance Data（实例数据）：** 对象的实例字段数据。
+ **Array Length（数组长度）：** 仅适用于数组对象，表示数组的长度。
+ **Monitor（监视器）：** 用于实现线程同步的监视器锁，记录持有锁的线程标识符以及等待队列等相关信息。

需要注意的是，具体的对象头结构可能因Java虚拟机的实现而有所不同。此外，不同的对象类型（如普通对象和数组对象）可能有略微不同的对象头结构。因此，上述示例只是一个一般性的参考，并不代表所有情况下的确切结构。


## synchronized锁升级过程

锁的升级是指锁的状态从无锁状态到偏向锁状态，再到轻量级锁状态，最后升级为重量级锁状态的过程。这个过程称为锁的膨胀（Lock Coarsening）。

以下是一般情况下synchronized锁的升级过程：

**1、无锁状态（Unlocked）：** 初始状态下，对象处于无锁状态，任何线程都可以访问该对象。

**2、偏向锁状态（Biased Locking）：** 当一个线程第一次进入synchronized代码块时，对象会尝试升级为偏向锁。这意味着该线程获取了对象的锁，并将其标记为拥有该锁的线程。在偏向锁状态下，当没有竞争时，拥有偏向锁的线程可以无需争夺锁而直接进入临界区。这提高了单线程执行的性能。

**3、轻量级锁状态（Lightweight Locking）：** 如果有多个线程尝试竞争同一个对象的锁，偏向锁会升级为轻量级锁。在轻量级锁状态下，锁的请求者会尝试使用CAS（Compare and Swap）操作来获取锁，而不是阻塞线程。如果CAS操作成功，线程可以进入临界区执行。如果CAS操作失败，表示有竞争发生，锁会升级为重量级锁。

**4、重量级锁状态（Heavyweight Locking）：** 当多个线程竞争同一个对象的锁且轻量级锁无法解决竞争时，锁会升级为重量级锁。在重量级锁状态下，竞争锁的线程会被阻塞，进入等待状态，只有持有锁的线程释放锁后，等待线程才有机会竞争锁。

锁的升级过程是为了在并发场景下提供更好的性能和资源利用。初始阶段使用偏向锁和轻量级锁来避免不必要的竞争，只有在有实际竞争时才升级为重量级锁。这样可以减少锁操作的开销，提高程序的并发性能。需要注意的是，锁的升级过程是根据具体的实现和运行时环境而定，不同的JVM可能有不同的实现策略和优化机制。

## 自旋（Spin Locking）

自旋（Spin Locking）通常在锁的轻量级锁状态中使用。

当线程尝试获取对象的轻量级锁时，如果CAS（Compare and Swap）操作失败，表示有竞争发生，但此时并不会立即将锁升级为重量级锁。相反，线程会进行自旋处理。

自旋处理是指线程在获取锁失败后，不立即阻塞，而是进行一段循环尝试获取锁的操作。线程会忙等待锁的释放，反复尝试CAS操作，期望其他线程能够迅速释放锁。如果在一定次数的自旋后仍未成功获取到锁，线程才会放弃自旋，将锁升级为重量级锁，并进入阻塞状态。

自旋处理的目的是避免线程频繁地在用户态和内核态之间切换，以提高性能。它适用于锁竞争时间短暂、线程竞争不激烈的情况。然而，如果自旋时间过长或线程竞争激烈，自旋处理可能会浪费CPU资源，并可能导致性能下降。

需要注意的是，自旋处理的具体策略和次数是由具体的JVM实现决定的，可以根据系统配置和运行环境进行调整。在JVM中，通过调整自旋次数的阈值和自旋后的退避策略等参数，可以对自旋处理进行优化和调整。

**自旋代码示例**
```java
import java.util.concurrent.atomic.AtomicBoolean;

public class SpinLockExample {
    private AtomicBoolean locked = new AtomicBoolean(false);

    public void acquireLock() {
        while (!locked.compareAndSet(false, true)) {
            // 自旋等待锁的释放
        }
    }

    public void releaseLock() {
        locked.set(false);
    }
}
```



